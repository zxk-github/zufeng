高阶函数
如果函数的参数是一个函数，或者这个函数返回一个新的函数，这个函数都叫高阶函数

使用 
AOP 面向切片编程
把一些核心的功能抽离出来，然后在他原有的基础上，不改变原有代码，添加一些自己的功能

防抖 截流

try catch只能用来捕获同步的错误

promise 解决的问题

函数的防抖和节流
函数节流：指定时间间隔内只会执行一次任务
函数防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行 (电梯只要门不关紧，这时候按按钮，电梯门依旧会重新打开)

// 这种一直监听是否到达底部的方式非常耗费性能
// 而在实际场景中需要这样进行处理，在滚动过程中，每隔一段时间去计算一次，函数的节流就是每隔一段时间去执行一次原本需要无时无刻都在执行的任务，所以在滚动事件中，添加节流函数是一次非常好的实践
$(window).on('scroll', function () {
    // 判断是否滚动到底部的逻辑
    let pageHeight = $('body').height(),
        scrollTop = $(window).scrollTop(),
        winHeight = $(window).height(),
        thresold = pageHeight - scrollTop - winHeight;
    if (thresold > -100 && thresold <= 20) {
        console.log('end');
    }
});

function throttle(fn, interval = 300) {
    let canRun = true;
    return function () {
        if (!canRun) return;
        canRun = false;
        setTimeout(() => {
            fn.apply(this, arguments);
            canRun = true;
        }, interval);
    };
}
$(window).on('scroll', throttle(function () {
    // 判断是否滚动到底部的逻辑
    let pageHeight = $('body').height(),
        scrollTop = $(window).scrollTop(),
        winHeight = $(window).height(),
        thresold = pageHeight - scrollTop - winHeight;
    if (thresold > -100 && thresold <= 20) {
        console.log('end');
    }
}));

函数防抖
每次input输入，判断用户名是否存在
好的用户体验和减少服务端压力的做法就是，用户输入之后的一段时间中没有内容输入话，就去请求，如果在后面的一段事件中还有输入那就不去请求
$('input.user-name').on('input', debounce(function () {
    $.ajax({
        url: `https://just.com/check`,
        method: 'post',
        data: {
            username: $(this).val(),
        },
        success(data) {
            if (data.isRegistered) {
                $('.tips').text('该用户名已被注册！');
            } else {
                $('.tips').text('恭喜！该用户名还未被注册！');
            }
        },
        error(error) {
            console.log(error);
        },
    });
}));
function debounce(fn, interval = 300) {
    let timeout = null;
    return function () {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            fn.apply(this, arguments);
        }, interval);
    };
}


// 节流
window.addEventListener('scroll', throttle(() => {
    console.log('程序执行一次')
}), false);
var throttle = function(fn, times=300) {
    let sys = true;
    return () => {
        if(!sys) {
            return;
        }
        sys = false;
        setTimeout(() => {
            fn();
            sys = true;
        },times)
    }
}

oInput.addEventListener('input', ,false);

var debounce = function(cb, times) {
    let timer = null;
    return () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            cb();
        }, times);
    }
}

 
lesson2 7.17
变量提升 function var import

var申明的变量会申明到全局上 污染全局环境， 没有块级作用域的概念

默认情况下，应该把变量申明在某一个作用域下
let const可以和{}连用，块级作用域， 不会申明到window上，回自己构建一个作用域，申明在自己的作用域里面


// 空间不销毁，执行完成之后，销毁不算闭包

Symbol(name) name充当着描述的角色，内部会将这个描述符toString()
如果对象的属性是Symbol类型的，那么这个key值是不可枚举的
const s4 = Symbol.for('xxx') 存在描述的不会重新申明，先看有没有，有直接取出来
Symbol.keyFor(s4) // xxx
es6中对象的key值可以是一个表达式
obj = {
    [key]: '123'
}
Symbol类型的key值是不可枚举的

Symbol具有源变成的功能。可以改变默认系统级的方法
let obj = {
    [Symbol.split]
}
Object.getOwnPropertySymbols(obj)
因为Symbol是独一无二的，并且是不可枚举的，所以可以作为一个对象的私有属性

// 结构相同 可以直接通过相同的结构来取值

对象的展开 剩余运算符... 分散数组和对象
let arr3 = [...arr1, ...arr2];
let obj = {...obj1 , ...obj2}

let {length}

解构赋值
剩余运算符... 可以使用在对象和数组中，只能用在之后以为，会把剩下的内容重新组合
Array.from()  根据长度遍历，然后专数组
[...{0: 'a', 1: 'b', length: 2}] 报错  ...是遍利器

...展开的值必须有[Symbol.iterator]属性   数组 arguments都有


JSON.parse(JSON.stringfy())

问题 
对象没有iterator为啥可以使用...
let obj1 = {a: 1}
let obj2 = {b: 2}
var obj = {...obj1, ...obj2}

注意看一下在Object上的静态方法，哪些适用数组

如果仅仅是把一个对象展开到另一个对象里面，这中间根本就不需要迭代的过程，只是相当于解包了，如果希望打印，那就需要遍历每一个值，这个时候就会报iterator错误


...有时候充当的是展开运算符比如console.log(...[1, 2, 3]) // 1,2,3
有时候充当的是剩余运算符比如 [1, ...rest] = [1, 2, 3]
当充当展开运算符的时候，后面的值必须要具有iterator接口
当充当剩余运算符的时候 let [1, ...rest] = [1, 2, 3]  或者 let {x, ...y} = {x: 1, y: 2, z:3} 这个时候是不需要具有iterator的
因为展开运算符展开的过程中会对值进行遍历，所有必须要有iterator，
但是剩余运算符不需要进行遍历，仅仅是一个解包取值的过程，所以不需要具有iterator

... 和Array.from区别

深拷贝和浅拷贝

set map不能放重复类型 
set实现了forEach方法
数组去重 交集 并集 差集



string set map array arguments 就这几个自带iterator吧

vue数据劫持

lesson3
node模块 是commonjs规范

commonjs require 动态引入： 代码执行的时候可以动态引入
if(true) {
    require('a.js');
}
inport 不能进行动态引入, 静态引入 必须出现在文件顶端, 代码执行之前获取到

模块作用 导入 导出

export只能导出一个接口，可以通过接口获取到对应的值
let a = 1;
export a;   // 这时候会报错，因为相当于export 1；1不是接口
export let a = 1;
规定了对外的接口a。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系
因为a是一个接口，所以a的值变化了，外面的使用的也会变化
import 有申明变量的作用，并且存在变量提升

试验性语法:动态倒入
直接使用原型继承 父类传参是一个问题，父类上对象的引用问题

类

属性
实例上的属性
公共属性

1. es6中的class申明的函数不能显示调用了
function Animal() {
    if(!(this instanceof Animal)) {
        throw new Error('TypeError: Class constructor Animal cannot be invoked without new')
    }
}

es6中
super作用
判断原型还是实例上的 hasOwnProperty
属性访问器
es5 es6如何继承类上的静态方法

super()在构造函数中，指代父类，在原型方法中指带父类原型


7.21
发布订阅模式 两个人没有关系
应用: promise 一个promise then多次
观察者模式 被观察者状态变化的时候 一一通知观察者

promsie中的链式调用中断(返回一个不成功也不失败的promise)

promsie只能不要结果，但是不会终止程序的执行

装饰器 AOP
1. 装饰类  可以在类上修饰 属性上修饰 方法上修饰
function add(target) {
    target.type = 'my'; 
}
@add
class my {

}
console.log(my.type) // my

2. 多个装饰器执行顺序 

3. 数组api
reduce 
应用 compose组合 将多个函数进行组合

4. 箭头函数没有this arguments prototype

5. 模版字符串

6. eventloop
函数执行的时候会创建执行上下文，执行结束会自动销毁执行上下文，全局上下文不会消失，只有浏览器关闭的时候才会消失
作用域是函数在定义的时候产生的

7. node全局变量
global process Buffer clearInterval/setInterval clearTimeout/setTimeout clearImmediate/setImmediate

node 文件中打印this 是module.exports

7.24



7.26
fs模块

util promisify inherits

event 

7.28
fs模块

文件操作
同步方法一般sync结尾 速度快可以立刻拿到结果，但是阻塞主线程
异步 不会阻塞主线程 缺点: 代码维护困难
fs.readFile(path, options, cb)读取文件内容  建议绝对路径
options 'utf8' {flags: , 'encoding': 'utf8'}
fs.writeFile(path, data, options, callback)
options flags mode encoding
上面都是执行小的文件方案，64k以下
fs.copyFile()

一个文件可以保存多个文件格式，但是存储的都是二进制数据
path.resolve() 如果没有参数，默认当前命令行的执行路径(等同于process.cwd())

理想状态 部分读取完毕之后写入
打开文件
flags: 文件系统标志 r r+ w w+ a a+ 
fs.open(path, flags, mode, function(err, fd) {  // fd file descriptor  

})
读取文件
fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
    fd 文件标记符
    buffer 读取数据放入的缓存区表示读取到那个内存中
    offset 从buffer的那个位置开始写入
    length 指定需要读取的字节数
    position 表示文件中开始读取的位置 null node会自己维护
    bytesRead 真正读取到的长度
    buffer 真正读取到的数据
})
写入文件
fs.write(fd, buffer, offset, length, position, function(err, bytesWritten, buffer ) {
    fd 文件标记符
    buffer 读取到的数据
    offset 从buffer的那个位置开始写
    length 写入的长度
    position 写到文件的那个位置 null的时候，会自己维护写入位置
    bytesWritten 成功写入的长度
    buffer 真正写入的数据
})
关闭文件
fs.close(fd, () => {})  

目录操作
fs.access(path, options, cb) 文件是否具有某一个权限 或者判断文件是不是存在
fs.stat 文件状态
fs.mkdir() 创建文件夹  创建下一级必须保证上一级存在
fs.mkdir(path, options, () => {
    options { recursive: true, mode: ''}
})
fs.rmdir 删除文件夹  文件夹不为空不能删除
fs.rename 文件重命名
fs.unlink 删除文件
fs.readdir 读取目录内容 文件和文件夹组成的数组

cad dac 中序
acd adc 先序

遍历方式 
深度一直到底 
广度 一层一层

先序深度

流stream
文件可读流
fs.createReadStream(path, {
    flags: '',
    encoding: null, 读取到的结果都是buffer
    mode: '',
    autoClose: true, 读取完成之后自动关闭
    start: 读取开始位置 
    end: 读取结束位置
    highWaterMark: 每次读取最大长度， 最高水位线 
})
默认是非流动模式
fs.on('open', (err, fd) => {

})
fs.on('data', (err, data) => { // 启动读取， 会被多次触发

})
fs.on('end', () => {

})
fs.on('error', () => {

})
fs.on('close', () => {

})
只有文件才有open/close事件
fs.resume()
fs.pause()

可写流
如何解决异步并发问题(比如说多个异步都向操作同一个文件) 放进缓存中 然后排队一个个执行
ws = fs.createWriteStream(path, {
    flags: 文件标记符
    encoding: 编码
    mode:   权限
    autoClose:   写入完成之后是否立即关闭
    start: 写入的开始位置
    highWaterMark: 16k 给的超出了 只能放到内存中
})
 
let flag = ws.write(data, encoding, function() {
    data // 只支持string/buffer 向文件中写入内容
}) 
flag // 表示写入数据是否达到预期 true 预期内 false 预期外(暂存区已经满了不能要了)
超出缓存区返回false，但是不会丢失数据，不再接受数据

ws.end('ok') 关闭文件，并且遗言也会写入文件，关闭文件之后不能写入了
ws.on('drain', () => {
    drain事件代表的是内容达到预期highWaterMark后，当内存中的内容都写入完毕后还会触发此回调函数
})

on('data') on('end') 这种可读流
write()/end() 可写流
如果都调用 那就是双工流

管道
rs.pipe(ws) 异步，读一点写一点 不会导致内存溢出 缺点: 看不到文件内容
 
Duplex 双工流 可读可写
继承了readable和writable

转换流 Transform 双工流一种
crypto 加密的
MD5摘要算法 不能反解 不一样就会引起雪崩 长度固定

process.stdin.on('data', function(data) {
    console.log(data);
    process.stdin.write(data)
})
process.stdin.pipe(transform).pipe(process.stdin)

//转换流
transform充当可写可读流


7.31
客户端可以设置一些规则 服务端进行解析 反之 服务端设置一些规则 客户端解析
curl使用

请求带参数的两种方式 
1. /product/123
2. ?a=1&b=2

状态码是随意设置的


创建一个服务器
const server = http.createServer()  

//监听每次请求
server.on('request', (req, res) {
    获取请求行信息 req.method req.httpVersion req.url
    获取header头信息 req.getHeader['content-type']
    获取请求体 req是可读流
        const arr = [];
        req.on('data', (data) => {
            arr.push(data)
        })
        req.on('end', () => {
            console.log(Buffer.from(arr).toString())
        })
        
    响应相关
    设置响应状态码 res.statusCode = 404 
    设置头 res.setHeader('Content-type', 'text/plain')
    res是可写流
        res.write('hello')
        res.end('word')
})


// 创建client端
const client = http.request({ // client 意思就是req 此时是一个可写流
    // options
}, function(res) {
    // res server端的返回值 是一个可读流
    res.on('data', function(data) {
        console.log(data)
    })
    res.on('end', function() {
        console.log('读取完毕');
    })
})

client.write('aa')
client.end()


**  对于server端来说 req 是可读流 res是可写流
        创建 http.createServer().on('request', function(req, res) {})
    对于client端来说 req 是一个可写流 res是可读流
        创建 http.request(options, function() {}).write() 


path模块
path.basename 文件名
    .dirname 文件夹名称
    .extname 后缀名 
    .join([paths]) 路径合并 
    .parse(url) 解析url   
    .relative(from, to) from到to之间的相对路径
    .resolve([paths]) 将方法或者片段解析为绝对路径  后面的是绝对路径就会覆盖前面的

fs模块
  fs.stat(path, (stats) => {
      stats.isFile()
      stats.isDirectory()
  })  判断文件类型
  fs.access() 判断是否存在和具有某种权限 constants.F_OK constants.R_OK constants.W_OK
  fs.readdir() 读取文件夹下的内容

__dirname 当前文件所在的文件夹绝对路径
__filename 当前文件的绝对路径
process.cwd() 当前服务执行所在的文件夹


8.2
http缓存 
304是服务端设置的
强制缓存 logo 图片
Cache-Control: 'max-age=5'  // 5秒内再发起同样请求，就别来找我了 
Expires: new Date(Date.now()+20*1000).toGMTString()

Cache-Control: no-store  不缓存
               no-cache  缓存 但是每次都向服务器发起请求 询问

协商缓存  当强制缓存失效的时候，会启动协商缓存
1. 根据文件的最后修改时间，只要修改就就会失效，并且精确时间是秒，一秒内多次修改 检测不到
s --> b Last-Modified: stats.ctime.toGMTString()
stats.ctime文件的最后修改时间
b --> s If-Modified-Since: 

2. 比较指纹 存在性能问题 因为每次都需要读取文件
md5 = crypto.createHash('md5').update(filecontent).digest('base64)
s --> b Etag: md5

b --> s If-None-Match

修改时间+文件大小

规则
先做强制缓存

文件压缩(转化流 zlip) 
gzip deflate
重复率越高 压缩越好
浏览器支持的压缩格式 Accept-Encoding
服务器压缩的方式 Content-Encoding: gzip/deflate

user-agent

res.statusCode = 302  /  301
res.setHeader('Location', 'www.baidu.com');

8.4 
跨域
xml.responseText 都是字符串
xml.response 区别 不设置json类型就是字符串，设置就是json

跨域只会在浏览器中才会存在  webapp不存在跨域问题

跨域: 浏览器的同源策略
协议 主机名 端口号 有一个不同就是跨域
iframe websocket jsonp cors

简单请求
加上header设置就是发送复杂请求

复杂请求 先发一次方法是options的预请求
 
服务端设置
res.setHeader()
Access-Control-Allow-Origin  允许的源
Access-Control-Allow-Methods 允许的请求方法
Access-Control-Allow-Headers 允许那些头
Access-Control-Max-Age   多久之内不需要进行预请求
Access-Control-Credentials: 'true'

如果跨域是不允许携带cookie的

uuid 计算出不会重复的值

文件上传

多语言
req aceept-language:zh-CN,q=1

放盗链
可以判断当前资源是否被被人引用

下午 
反向代理 正向代理

代理帮我干一些事情
代理对服务其来说是透明的，他不知道是客户端还是代理服务器访问的 权限校验 或者添加一些功能
反向代理 客户端直接访问代理服务器 可以做缓存 cdn 虚拟主机配置多域名

webpack proxy 就是反向代理
http-proxy

koa

express 大而全全是使用es3写 处理异步不优雅，处理异步都是基于异步
koa 基于promise的

context 方便req, res 都挂在在了ctx下 ctx包含了res, req
request 包装了req中的属性和方法
response 包装了res中的属性和方法

req res 原生的
request response都是二次封装的
ctx集成了上面的四个

中间件 
1中间执行的逻辑，
2可以在ctx扩展一些属性或者方法
3决定是否向下执行

koa-bodyParser 解析请求体的，但是不支持文件上传

访问不同的路径 返回不同文件 

koa-static koa的静态服务插件

8.3
koa-router

app.use((ctx, next) => {

})

koa-generator koa的生成器
npm install koa-generator -g
koa2  projectName

koa-json解析json

方法405 服务器允许的方法 Method not Allow

session
cookie 每次请求都会自动带过去，为了解决http无状态为题产生的，可以保持前后通信 4K 不能什么都放到cookie中 会造成流量浪费 存放到客户端中没请求会自动带过去
localStorage 不删就一直存在，不能跨域 5M
sessionStorage 只存在当前绘话 5M

domain 域名：cookie可以在哪个域名下生效，但是可以与子域共享
path 在那个路径下生效, 不再那个路径下，浏览器就不会显示出来对应的cookie
Expires/Max-Age  session 应用关掉就消失 
Expires 绝对 Max-Age 相对
Http true 客户端不能改 

req.headers.cookie
res.setHeader('Set-Cookie', 'count=10, domain=a.zufeng.com, path=/user, max-age=10, httpOnly=true')
res.setHeader('Set-Cookie', 'count=10, domain=a.zufeng.com, path=/user, max-age=10`') 后面会覆盖前面的
res.setHeader('Set-Cookie', ['count=10, domain=a.zufeng.com, path=/user, max-age=10`', 'name=12']) 设置多个

设置httpOnly通过document.cookie不能获取到
一般情况下，设置httpOnly只能防止前端js代码修改

设置的时候加上签名，如果客户端改了，就不识别
crypto = require('crypto);
// sha256 加盐算法
let sign = crypto.createHmac('sha256', secrite).update(value+'').digest('base64').replace(/\+|\/|\=/, '')
value = value+'.'+sign;

读的时候
+ / = 在base64中存在bug 所以一般会去除

uuid 生成唯一一个值
session session是基于cookie的 session是保存在服务端的，可以保存一些敏感信息
服务端利用用户信息生成一段session 